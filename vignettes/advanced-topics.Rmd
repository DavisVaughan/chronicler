---
title: "An implementation of the logger monad"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An implementation of the logger monad}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(chronicler)
library(testthat)
```

# Introduction

`{chronicler}` is an implementation of a logger monad. A monad is a computation device that offers
three things:

- the possibility to embellish functions so they can provide additional output without having to touch the function's core implementation;
- a way to compose these embellished functions;
- a way to convert "normal" objects to "monadic" objects (monadic objects are the output of the embellished functions)

To understand what a monad is, I believe it is useful to explain what sort of problem monads solve.

Suppose for instance that you wish for your functions to provide a log when they're run. If your
function looks like this:

```{r}
my_sqrt <- function(x){

  sqrt(x)

}

```

Then you would need to rewrite it like this:

```{r}
my_sqrt <- function(x, log = ""){

  list(sqrt(x),
       c(log,
         paste0("Running sqrt with input ", x)))

}

```

There are two problems with such an implementation:

- we need to rewrite every function;
- these functions don't compose:

What do I mean with "these functions don't compose"? Consider another such function `my_log()`:

```{r}
my_log <- function(x, log = ""){

  list(log(x),
       c(log,
         paste0("Running log with input ", x)))

}

```

`sqrt()` and `log()` compose, or rather, they can be chained:

```{r}
10 |>
  sqrt() |>
  log()

```

while this is not true for `my_sqrt()` and `my_log()`:

```{r, eval = FALSE}
10 |>
  my_sqrt() |>
  my_log()

```

```
Error in log(x) (from #3) : non-numeric argument to mathematical function
```

This is because `my_log()` expects a number, not a list which is what `my_sqrt()` returns.

A "monad" is what we need to solve these two problems. The first problem, not having to rewrite
every function, can be tackled using [function factories](https://adv-r.hadley.nz/function-factories.html).
Let's write one for our problem:

```{r}
logit <- function(.f, ..., log = NULL){

  fstring <- deparse(substitute(.f))

  function(..., .log = log){

    list(result = .f(...),
         log = c(paste0("Running ", fstring, " with argument ", ...),
                 .log))
  }
}

```


Then, to keep track of all the logs from all your functions, you would need to create a global log 
variable, which would then be given as an argument to each function (and you would need to rewrite
each function to use this log). The problems here are:

- you need to rewrite the same code to handle logs over and over again for each function. It would be better to avoid repeating oneself;
- the functions now do two things that are completely unrelated: they perform their computation but also handle logs. It easier to reason about functions that only perform one thing;
- having a global variable (in this case the global log) that keeps getting accessed and modified by other functions is asking for trouble. Also parallelization would mess up the log.

Enter the monad, a way to handle computations that would typically require running impure code (or 
changing the implementation of the needed functions), purely.


Monads need to satisfy the so-called "monadic laws".

# Monadic laws

The first law states that passing a monadic value to a monadic function using `bind()` 
(or in the case of the `{chronicler}` package `bind_record()`) or passing a value to a monadic
function is the same.

## First law

```{r}
a <- as_chronicle(10)
r_sqrt <- record(sqrt)
 
test_that("first monadic law", {
  expect_equal(bind_record(a, r_sqrt)$value, r_sqrt(10)$value)
})

```

Turns out that this is not quite the case here; the logs of the two objects will be slightly 
different. So I only check the value.

## Second law

The second law states that binding a monadic value to `return()` (called `as_chronicle()` in
this package, in other words, the function that coerces values to chronicler objects) does
nothing. Here again we have an issue with the log, that's why I focus on the value:

```{r}
test_that("second monadic law", {
  expect_equal(bind_record(a, as_chronicle)$value, a$value)
})

```

## Third law

The third law is about associativity; applying monadic functions successively or composing them
first gives the same result.

```{r}
a <- as_chronicle(10)

r_sqrt <- record(sqrt)
r_exp <- record(exp)
r_mean <- record(mean)

test_that("third monadic law", {
  expect_equal(
    (bind_record(a, r_sqrt)) |>
      bind_record(r_exp),
    a |>
    (\(x) bind_record(x, r_sqrt) |> bind_record(r_exp))(),
  tolerance = .01
  )
})

```

## flatmap and bind

```{r}

r_sqrt <- record(sqrt)
r_exp <- record(exp)
r_mean <- record(mean)

a <- 1:10 |>
  r_sqrt() |>
  bind_record(r_exp) |>
  bind_record(r_mean)

flatmap_record <- purrr::compose(join_record, fmap_record)

b <- 1:10 |>
  r_sqrt() |>
  flatmap_record(r_exp) |>
  flatmap_record(r_mean)

identical(a$value, b$value)

```
